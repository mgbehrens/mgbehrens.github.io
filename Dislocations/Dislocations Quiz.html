<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0b0f14" />
  <title>Dislocations Quiz - 20 Questions</title>
    <style>
    :root{
      --bg: #0b0f14;
      --text: #e6edf3;
      --muted: #9aa7b2;
      --card: #0f1620;
      --border: #263241;
      --shadow: rgba(0,0,0,.25);

      --btn-bg: #162232;
      --btn-bg-hover: #1b2a3e;
      --btn-border: #2a3a4f;
      --btn-text: var(--text);

      --primary: #3b82f6;
      --primary-hover: #2563eb;

      --ok-bg: rgba(34, 197, 94, 0.12);
      --ok-border: rgba(34, 197, 94, 0.35);

      --bad-bg: rgba(239, 68, 68, 0.12);
      --bad-border: rgba(239, 68, 68, 0.35);

      --focus: rgba(59, 130, 246, 0.45);
    }

    /* Optional: if user prefers light mode, respect it */
    @media (prefers-color-scheme: light){
      :root{
        --bg: #ffffff;
        --text: #111827;
        --muted: #4b5563;
        --card: #ffffff;
        --border: #d1d5db;
        --shadow: rgba(0,0,0,.08);

        --btn-bg: #f3f4f6;
        --btn-bg-hover: #e5e7eb;
        --btn-border: #d1d5db;
        --btn-text: #111827;

        --primary: #1f6feb;
        --primary-hover: #1857bd;

        --ok-bg: #e9f7ef;
        --ok-border: #bfe7cd;

        --bad-bg: #fdecea;
        --bad-border: #f5c2bd;

        --focus: rgba(31, 111, 235, 0.35);
      }
    }

    *{ box-sizing: border-box; }
    body{
      font-family: Arial, sans-serif;
      margin: 24px;
      line-height: 1.4;
      background: var(--bg);
      color: var(--text);
    }
    .wrap { max-width: 800px; margin: 0 auto; }

    .card{
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      box-shadow: 0 6px 18px var(--shadow);
    }

    .muted{ color: var(--muted); font-size: 0.95rem; }

    .q-title{ margin: 0 0 8px; }

    .choices{ list-style: none; padding: 0; margin: 0; }
    .choices li{ margin: 10px 0; }

    label{ cursor: pointer; }
    input[type="radio"]{
      accent-color: var(--primary);
      transform: translateY(1px);
    }

    /* Focus visibility */
    button:focus, input[type="radio"]:focus{
      outline: 3px solid var(--focus);
      outline-offset: 2px;
    }

    .btnrow{
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 12px;
    }

    button{
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid var(--btn-border);
      background: var(--btn-bg);
      color: var(--btn-text);
      cursor: pointer;
    }
    button:hover{ background: var(--btn-bg-hover); }

    button.primary{
      background: var(--primary);
      color: #fff;
      border-color: var(--primary);
    }
    button.primary:hover{ background: var(--primary-hover); }

    .feedback{
      margin-top: 10px;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
    }
    .ok{ background: var(--ok-bg); border-color: var(--ok-border); }
    .bad{ background: var(--bad-bg); border-color: var(--bad-border); }

    .hidden{ display: none; }

    .progress{
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }
    .pill{
      padding: 4px 10px;
      border: 1px solid var(--border);
      border-radius: 999px;
      font-size: 0.9rem;
      background: rgba(255,255,255,.03);
    }

    .explain{ margin-top: 8px; }
  
    /* Fireworks overlay (shown only on 20/20) */
    canvas.fireworks{
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 9999;
    }

  </style>
</head>

<body>

<div class="quiz-header">
  <a href="../index.html" class="index-link" aria-label="Back to Home">← Back to Home</a>
</div>

<style>
  .quiz-header {
    max-width: 1100px;
    margin: 0 auto 12px auto;
    padding: 12px 16px 0 16px;
    display: flex;
    justify-content: flex-end;
  }

  .index-link {
    text-decoration: none;
    font-weight: 600;
    color: #eaeaf0;
    padding: 6px 10px;
    border-radius: 8px;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.18);
  }

  .index-link:hover {
    background: rgba(255,255,255,0.14);
  }
</style>




  <canvas id="fireworks" class="fireworks" style="display:none;"></canvas>

  <div class="wrap">
     <h1>Dislocations quiz: 20 Questions</h1>
    <p class="muted">Assesses students’ understanding of dislocations as crystal defects, including edge, screw, and mixed dislocations, their role in plastic deformation, slip systems, work hardening, and strengthening mechanisms, and how dislocation behaviour influences strength, ductility, and failure in engineering materials.</p>

    <div class="card progress">
      <div>
        <div class="pill" id="progressText">Question 1 of 1</div>
      </div>
      <div class="pill" id="scoreText">Score: 0</div>
    </div>

    <div class="card" id="quizCard">
      <h2 class="q-title" id="questionText">Loading…</h2>
      <p class="muted" id="questionMeta"></p>

      <form id="choicesForm">
        <ul class="choices" id="choicesList"></ul>
      </form>

      <div class="btnrow">
        <button class="primary" id="checkBtn" type="button">Check answer</button>
        <button id="nextBtn" type="button" class="hidden">Next</button>
        <button id="restartBtn" type="button">Restart</button>
      </div>

      <div id="feedbackBox" class="feedback hidden"></div>
    </div>

    <div class="card hidden" id="summaryCard">
      <h2>Results</h2>
      <p id="summaryText"></p>
      <button class="primary" id="restartBtn2" type="button">Restart quiz</button>
    </div>
  </div>

  <script>
    // =========================
    // 1) QUESTION BANK (EDIT ME)
    // =========================
    // correctIndex is 0-based (0 = A, 1 = B, etc.)

const QUESTIONS = [
  {
    topic: "Definition",
    question: "What is a dislocation in a crystalline material?",
    choices: [
      "A point defect caused by a missing atom",
      "A line defect representing a disruption in the crystal lattice",
      "A grain boundary between crystals",
      "A surface crack"
    ],
    correctIndex: 1,
    explanation: "A dislocation is a line defect in the crystal lattice. It represents a region where atoms are misaligned, allowing plastic deformation to occur at much lower stresses than would be required for perfect crystals."
  },
  {
    topic: "Plastic Deformation",
    question: "Why are dislocations essential for plastic deformation in metals?",
    choices: [
      "They increase atomic bonding strength",
      "They allow layers of atoms to slip past each other at lower stress",
      "They prevent crack formation",
      "They increase elastic modulus"
    ],
    correctIndex: 1,
    explanation: "Dislocations enable plastic deformation by allowing atomic planes to move incrementally, rather than requiring all bonds across a plane to break simultaneously."
  },
  {
    topic: "Edge Dislocation",
    question: "An edge dislocation can be visualised as:",
    choices: [
      "A twisted crystal lattice",
      "An extra half-plane of atoms inserted into the lattice",
      "A missing row of atoms",
      "A rotated grain"
    ],
    correctIndex: 1,
    explanation: "An edge dislocation consists of an extra half-plane of atoms, producing compressive stress above the dislocation line and tensile stress below it."
  },
  {
    topic: "Screw Dislocation",
    question: "How does a screw dislocation differ from an edge dislocation?",
    choices: [
      "It produces no stress field",
      "Atomic planes form a helical or spiral structure around the dislocation line",
      "It only occurs in ceramics",
      "It cannot move under stress"
    ],
    correctIndex: 1,
    explanation: "In a screw dislocation, the lattice planes spiral around the dislocation line, producing shear stress and allowing slip in multiple directions."
  },
  {
    topic: "Mixed Dislocations",
    question: "Most real dislocations in metals are best described as:",
    choices: [
      "Pure edge dislocations",
      "Pure screw dislocations",
      "Mixed dislocations",
      "Point defects"
    ],
    correctIndex: 2,
    explanation: "Most dislocations contain both edge and screw components along their length and are therefore referred to as mixed dislocations."
  },
  {
    topic: "Slip Systems",
    question: "Dislocations move most easily along:",
    choices: [
      "Random crystal directions",
      "Slip planes and slip directions with high atomic packing density",
      "Grain boundaries only",
      "Amorphous regions"
    ],
    correctIndex: 1,
    explanation: "Slip occurs most readily on close-packed planes and directions because these require the least energy for atomic movement."
  },
  {
    topic: "Crystal Structure",
    question: "Which crystal structure generally has the greatest number of active slip systems?",
    choices: ["BCC", "FCC", "HCP", "Simple cubic"],
    correctIndex: 1,
    explanation: "FCC metals have many close-packed slip systems, making them highly ductile and able to deform easily."
  },
  {
    topic: "BCC Behaviour",
    question: "Why do BCC metals often show reduced ductility at low temperatures?",
    choices: [
      "They contain fewer dislocations",
      "Their slip systems are not close-packed and require higher stress to activate",
      "They contain more impurities",
      "They have lower melting points"
    ],
    correctIndex: 1,
    explanation: "In BCC metals, slip systems are not close-packed, so dislocation motion is more temperature dependent, leading to brittle behaviour at low temperatures."
  },
  {
    topic: "Dislocation Density",
    question: "What happens to dislocation density during plastic deformation?",
    choices: [
      "It decreases",
      "It remains constant",
      "It increases",
      "It disappears"
    ],
    correctIndex: 2,
    explanation: "Plastic deformation generates and multiplies dislocations, increasing dislocation density within the material."
  },
  {
    topic: "Work Hardening",
    question: "Why does increasing dislocation density increase material strength?",
    choices: [
      "Dislocations annihilate grain boundaries",
      "Dislocations block each other’s motion",
      "Dislocations increase atomic spacing",
      "Dislocations improve ductility"
    ],
    correctIndex: 1,
    explanation: "As dislocation density increases, dislocations interact and impede each other’s motion, requiring higher stress for further deformation."
  },
  {
    topic: "Yield Strength",
    question: "Yielding in a metal occurs when:",
    choices: [
      "Elastic strain reaches a maximum",
      "Dislocations begin to move in large numbers",
      "Grain boundaries fracture",
      "Atoms diffuse"
    ],
    correctIndex: 1,
    explanation: "Yielding corresponds to the onset of widespread dislocation motion, marking the transition from elastic to plastic deformation."
  },
  {
    topic: "Grain Boundaries",
    question: "How do grain boundaries affect dislocation motion?",
    choices: [
      "They have no effect",
      "They act as barriers to dislocation movement",
      "They eliminate dislocations",
      "They increase slip length"
    ],
    correctIndex: 1,
    explanation: "Grain boundaries disrupt lattice continuity and block dislocation motion, increasing strength (Hall–Petch relationship)."
  },
  {
    topic: "Hall–Petch Relationship",
    question: "According to the Hall–Petch relationship, reducing grain size will:",
    choices: [
      "Decrease strength",
      "Increase ductility only",
      "Increase yield strength",
      "Have no effect"
    ],
    correctIndex: 2,
    explanation: "Smaller grains mean more grain boundaries, which impede dislocation motion and increase yield strength."
  },
  {
    topic: "Solid Solution Strengthening",
    question: "How do alloying elements strengthen metals via dislocations?",
    choices: [
      "They eliminate dislocations",
      "They distort the lattice and impede dislocation motion",
      "They increase grain size",
      "They promote slip"
    ],
    correctIndex: 1,
    explanation: "Substitutional or interstitial atoms distort the lattice, creating stress fields that interact with and hinder dislocation movement."
  },
  {
    topic: "Precipitation Hardening",
    question: "In precipitation hardening, strengthening occurs because:",
    choices: [
      "Grains grow larger",
      "Precipitates block dislocation motion",
      "Dislocations disappear",
      "Carbon content decreases"
    ],
    correctIndex: 1,
    explanation: "Fine precipitates act as obstacles to dislocation motion, requiring additional stress for dislocations to bypass or cut through them."
  },
  {
    topic: "Temperature Effects",
    question: "What effect does increasing temperature generally have on dislocation motion?",
    choices: [
      "Reduces dislocation mobility",
      "Has no effect",
      "Increases dislocation mobility",
      "Eliminates dislocations"
    ],
    correctIndex: 2,
    explanation: "Higher temperatures provide thermal energy that helps dislocations overcome obstacles, increasing ductility and reducing strength."
  },
  {
    topic: "Creep",
    question: "Which deformation mechanism involves dislocation motion at elevated temperatures over time?",
    choices: [
      "Fatigue",
      "Creep",
      "Brittle fracture",
      "Elastic recovery"
    ],
    correctIndex: 1,
    explanation: "Creep deformation involves time-dependent dislocation motion, climb, and diffusion at elevated temperatures."
  },
  {
    topic: "Dislocation Climb",
    question: "Dislocation climb differs from slip because it:",
    choices: [
      "Occurs without diffusion",
      "Requires atomic diffusion and elevated temperature",
      "Occurs only at room temperature",
      "Does not contribute to deformation"
    ],
    correctIndex: 1,
    explanation: "Climb involves diffusion of vacancies or atoms, allowing dislocations to move out of their slip plane, which is important in creep."
  },
  {
    topic: "Brittle vs Ductile",
    question: "Materials with limited dislocation motion tend to fail by:",
    choices: [
      "Ductile fracture",
      "Plastic flow",
      "Brittle fracture",
      "Necking"
    ],
    correctIndex: 2,
    explanation: "When dislocation motion is restricted, materials cannot plastically deform to relieve stress, leading to brittle fracture."
  },
  {
    topic: "Engineering Significance",
    question: "Why is understanding dislocations critical in materials engineering?",
    choices: [
      "They determine colour",
      "They control plastic deformation, strength, and failure behaviour",
      "They only affect surface finish",
      "They determine density"
    ],
    correctIndex: 1,
    explanation: "Dislocations govern how materials deform, strengthen, and fail, making them central to material selection, processing, and performance."
  }
];

    // =========================
    // 2) QUIZ ENGINE (NO NEED TO EDIT)
    // =========================
    let idx = 0;
    let score = 0;
    let answered = false; // prevent double scoring

    const progressText = document.getElementById("progressText");
    const scoreText = document.getElementById("scoreText");
    const questionText = document.getElementById("questionText");
    const questionMeta = document.getElementById("questionMeta");
    const choicesList = document.getElementById("choicesList");
    const feedbackBox = document.getElementById("feedbackBox");

    const checkBtn = document.getElementById("checkBtn");
    const nextBtn = document.getElementById("nextBtn");
    const restartBtn = document.getElementById("restartBtn");
    const restartBtn2 = document.getElementById("restartBtn2");

    const quizCard = document.getElementById("quizCard");
    const summaryCard = document.getElementById("summaryCard");
    const summaryText = document.getElementById("summaryText");

    function renderQuestion() {
      answered = false;
      feedbackBox.className = "feedback hidden";
      feedbackBox.innerHTML = "";
      nextBtn.classList.add("hidden");

      const q = QUESTIONS[idx];
      progressText.textContent = `Question ${idx + 1} of ${QUESTIONS.length}`;
      scoreText.textContent = `Score: ${score}`;
      questionText.textContent = q.question;
      questionMeta.textContent = q.topic ? `Topic: ${q.topic}` : "";

      // Build choices (radio buttons)
      choicesList.innerHTML = "";
      q.choices.forEach((choice, i) => {
        const li = document.createElement("li");
        const id = `q${idx}_c${i}`;
        li.innerHTML = `
          <label for="${id}">
            <input type="radio" name="choice" id="${id}" value="${i}" />
            ${choice}
          </label>
        `;
        choicesList.appendChild(li);
      });
    }

    function getSelectedIndex() {
      const selected = document.querySelector('input[name="choice"]:checked');
      return selected ? Number(selected.value) : null;
    }

    function lockChoices() {
      document.querySelectorAll('input[name="choice"]').forEach(el => el.disabled = true);
    }

    function unlockChoices() {
      document.querySelectorAll('input[name="choice"]').forEach(el => el.disabled = false);
    }

    function showFeedback(isCorrect, q) {
      feedbackBox.classList.remove("hidden");
      feedbackBox.classList.toggle("ok", isCorrect);
      feedbackBox.classList.toggle("bad", !isCorrect);

      const correctText = q.choices[q.correctIndex];
      feedbackBox.innerHTML = `
        <strong>${isCorrect ? "Correct!" : "Not quite."}</strong>
        <div class="explain">
          ${isCorrect ? "" : `Correct answer: <strong>${correctText}</strong><br/>`}
          ${q.explanation ? q.explanation : ""}
        </div>
      `;
    }


    // =========================
    // Fireworks (perfect score)
    // =========================
    const fwCanvas = document.getElementById("fireworks");
    const fwCtx = fwCanvas.getContext("2d");
    let fwRunning = false;
    let fwParticles = [];
    let fwAnimId = null;

    function resizeFireworks(){
      const dpr = window.devicePixelRatio || 1;
      fwCanvas.width = Math.floor(window.innerWidth * dpr);
      fwCanvas.height = Math.floor(window.innerHeight * dpr);
      fwCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    window.addEventListener("resize", () => {
      if (fwRunning) resizeFireworks();
    });

    function rand(min, max){ return Math.random() * (max - min) + min; }

    function spawnBurst(x, y){
      const count = Math.floor(rand(60, 120));
      for (let i = 0; i < count; i++){
        const angle = rand(0, Math.PI * 2);
        const speed = rand(1.5, 6.0);
        fwParticles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: rand(40, 90),
          maxLife: 0, // set below
          size: rand(1.2, 2.6),
          hue: rand(0, 360)
        });
      }
      // assign maxLife after creation so we can fade nicely
      for (let p of fwParticles){
        if (p.maxLife === 0) p.maxLife = p.life;
      }
    }

    function tickFireworks(){
      fwCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);

      // Occasionally spawn a new burst
      if (Math.random() < 0.08){
        spawnBurst(rand(window.innerWidth * 0.15, window.innerWidth * 0.85),
                  rand(window.innerHeight * 0.15, window.innerHeight * 0.55));
      }

      const gravity = 0.06;
      const drag = 0.985;

      fwParticles = fwParticles.filter(p => p.life > 0);
      for (let p of fwParticles){
        p.life -= 1;
        p.vx *= drag;
        p.vy = p.vy * drag + gravity;

        p.x += p.vx;
        p.y += p.vy;

        const t = p.life / p.maxLife; // 1..0
        const alpha = Math.max(0, Math.min(1, t));

        fwCtx.beginPath();
        fwCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        fwCtx.fillStyle = `hsla(${p.hue}, 100%, 60%, ${alpha})`;
        fwCtx.fill();
      }

      fwAnimId = requestAnimationFrame(tickFireworks);
    }

    function startFireworks(){
      if (fwRunning) return;
      fwRunning = true;
      fwParticles = [];
      fwCanvas.style.display = "block";
      resizeFireworks();

      // Kick off with a few bursts
      for (let i = 0; i < 4; i++){
        spawnBurst(rand(window.innerWidth * 0.2, window.innerWidth * 0.8),
                  rand(window.innerHeight * 0.2, window.innerHeight * 0.55));
      }

      tickFireworks();

      // Stop after ~6 seconds (keeps it fun, not annoying)
      setTimeout(stopFireworks, 6000);
    }

    function stopFireworks(){
      if (!fwRunning) return;
      fwRunning = false;
      if (fwAnimId) cancelAnimationFrame(fwAnimId);
      fwAnimId = null;
      fwParticles = [];
      fwCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
      fwCanvas.style.display = "none";
    }


    function finishQuiz() {
      quizCard.classList.add("hidden");
      summaryCard.classList.remove("hidden");
      summaryText.textContent = `You scored ${score} out of ${QUESTIONS.length}.`;
      if (score === QUESTIONS.length) startFireworks();
    }

    function restartQuiz() {
      idx = 0;
      score = 0;
      answered = false;
      summaryCard.classList.add("hidden");
      quizCard.classList.remove("hidden");
      unlockChoices();
      renderQuestion();
    }

    checkBtn.addEventListener("click", () => {
      if (answered) return;

      const selectedIndex = getSelectedIndex();
      if (selectedIndex === null) {
        feedbackBox.className = "feedback bad";
        feedbackBox.textContent = "Please select an answer before checking.";
        return;
      }

      const q = QUESTIONS[idx];
      const isCorrect = selectedIndex === q.correctIndex;

      if (isCorrect) score += 1;
      answered = true;

      lockChoices();
      showFeedback(isCorrect, q);
      scoreText.textContent = `Score: ${score}`;
      nextBtn.classList.remove("hidden");
    });

    nextBtn.addEventListener("click", () => {
      idx += 1;
      if (idx >= QUESTIONS.length) {
        finishQuiz();
      } else {
        unlockChoices();
        renderQuestion();
      }
    });

    restartBtn.addEventListener("click", restartQuiz);
    restartBtn2.addEventListener("click", restartQuiz);

    // Start
    renderQuestion();
  </script>
</body>
</html>
